---
alwaysApply: true
---

0. Special Rule for Render

Do not push to GitHub just to test fixes.

Do not change working codes and features only the issued command or fixed are to be worked.

Cursor must confirm fixes locally first (e.g., linting, type checks, running dev server).

Only push when changes are:

✅ New features

✅ Critical bug fixes

✅ Security fixes

❌ Not just “trial/error” adjustments that could cause repeated Render redeploys

1. General Rules

Code must be simple, readable, and maintainable.

Never overwrite working code → only change requested parts.

Keep files under 250 lines → split into /components, /utils, or /hooks.

Always add comments for complex logic.

Naming:

camelCase → variables & functions

PascalCase → components

snake_case → database fields

2. UI / Frontend (Expo Go + React Native)

Colors:

White #FFFFFF

Dark gray #202021 for UI elements

Style → modern, minimal, professional.

Validation:

Show small inline errors ("Invalid input, please try again.")

Never crash the app on bad input.

Navigation:

Route by isAdmin → User Tabs vs Admin Tabs.

Screens:

User:

Home → post images (like-only).

Pets → add pet profiles.

Maps → show shops.

Profile → logout, edit profile.

Admin:

Dashboard → graphs (users + pets).

Shops → add/edit via map picker (no manual lat/lng).

3. Backend (Next.js + Prisma + Supabase + Render)

Use Supabase for DB + storage.

Use Prisma for all queries.

Use Next.js API routes for backend logic.

API JSON response format must always be:

{
  "success": true/false,
  "data": {},
  "error": "Error message if any"
}


Wrap DB calls in try/catch with error logging.

File uploads:

Use formidable or Supabase direct upload (Render avoids multer file-system issues).

Store file URL/path in DB.

4. Error Handling & Logging

Pattern:

try {
  // logic
} catch (error) {
  console.error("FeatureName Error:", error);
  // Show friendly message in UI
}


Rules:

Console logs → for devs.

User → minimal, non-technical error message.

Never crash app with red screens.

5. File & Code Structure

Two main folders:

/frontend → Expo + React Native

/backend → Next.js + Prisma

Frontend:

/components → reusable UI

/screens → screens

/utils → helpers

/hooks → custom hooks

Keep 1 screen = 1 file.

Split big files into helpers.

6. Deployment Rules

Database: Supabase

Backend: Render (no Vercel unless migrated)

Frontend: Expo Go (dev), build APK for release

Before deploy:

Linting + build must pass locally

No experimental/test code pushed

7. Best Practices (Cursor must always enforce)
Consistency

Prettier + ESLint formatting

Stick to palette (white + dark gray)

Code Quality

Reusable components/functions

Avoid duplicate code

Performance

Optimize Prisma queries

Avoid unnecessary re-renders

State Management

React hooks (useState, useEffect, useContext)

Data fetching → React Query or SWR

Scalability

Code structured for future features

Use constants/config files for URLs, colors

Security

Sanitize all inputs

Never expose secrets in frontend → use .env

Maintainability

Small, focused functions

Comment tricky parts

Use descriptive names0. Special Rule for Render

Do not push to GitHub just to test fixes.

Cursor must confirm fixes locally first (e.g., linting, type checks, running dev server).

Only push when changes are:

✅ New features

✅ Critical bug fixes

✅ Security fixes

❌ Not just “trial/error” adjustments that could cause repeated Render redeploys

1. General Rules

Code must be simple, readable, and maintainable.

Never overwrite working code → only change requested parts.

Keep files under 250 lines → split into /components, /utils, or /hooks.

Always add comments for complex logic.

Naming:

camelCase → variables & functions

PascalCase → components

snake_case → database fields

2. UI / Frontend (Expo Go + React Native)

Colors:

White #FFFFFF

Dark gray #202021 for UI elements

Style → modern, minimal, professional.

Validation:

Show small inline errors ("Invalid input, please try again.")

Never crash the app on bad input.

Navigation:

Route by isAdmin → User Tabs vs Admin Tabs.

Screens:

User:

Home → post images (like-only).

Pets → add pet profiles.

Maps → show shops.

Profile → logout, edit profile.

Admin:

Dashboard → graphs (users + pets).

Shops → add/edit via map picker (no manual lat/lng).

3. Backend (Next.js + Prisma + Supabase + Render)

Use Supabase for DB + storage.

Use Prisma for all queries.

Use Next.js API routes for backend logic.

API JSON response format must always be:

{
  "success": true/false,
  "data": {},
  "error": "Error message if any"
}


Wrap DB calls in try/catch with error logging.

File uploads:

Use formidable or Supabase direct upload (Render avoids multer file-system issues).

Store file URL/path in DB.

4. Error Handling & Logging

Pattern:

try {
  // logic
} catch (error) {
  console.error("FeatureName Error:", error);
  // Show friendly message in UI
}


Rules:

Console logs → for devs.

User → minimal, non-technical error message.

Never crash app with red screens.

5. File & Code Structure

Two main folders:

/frontend → Expo + React Native

/backend → Next.js + Prisma

Frontend:

/components → reusable UI

/screens → screens

/utils → helpers

/hooks → custom hooks

Keep 1 screen = 1 file.

Split big files into helpers.

6. Deployment Rules

Database: Supabase

Backend: Render (no Vercel unless migrated)

Frontend: Expo Go (dev), build APK for release

Before deploy:

Linting + build must pass locally

No experimental/test code pushed

7. Best Practices (Cursor must always enforce)
Consistency

Prettier + ESLint formatting

Stick to palette (white + dark gray)

Code Quality

Reusable components/functions

Avoid duplicate code

Performance

Optimize Prisma queries

Avoid unnecessary re-renders

State Management

React hooks (useState, useEffect, useContext)

Data fetching → React Query or SWR

Scalability

Code structured for future features

Use constants/config files for URLs, colors

Security

Sanitize all inputs

Never expose secrets in frontend → use .env

Maintainability

Small, focused functions

Comment tricky parts

Use descriptive names